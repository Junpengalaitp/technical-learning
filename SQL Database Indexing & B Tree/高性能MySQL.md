# 第五章
## 5.1 索引基础
### B-Tree(B+ Tree)索引
* 可以使用B-Tree索引的查询类
	* 全值匹配
	* 匹配最左前缀
	* 匹配列前缀：只匹配第一一列的值的开头部分(A -> Allen)
	* 匹配范围值
	* 精确匹配第一列并范围匹配另外一列
	* 只访问索引的查询(covering index)
	* 因为索引是有序存储的，ORDER BY可以和同样的方式使用索引
* B-Tree索引的限制
	* 如果不按照索引最左列开始查找，无法使用索引
	* 不能跳过索引中的列
	* 如果有某个列的范围查询，其右边的所有列都无法使用索引优化查找
* 全文索引
	* 查找文本中的关键词，而不是直接比较索引中的值

## 5.2 索引优点
* 大大减少了服务器需要扫描的数据量
* 索引可以帮助服务器避免排序和临时表
* 索引可以将随机IO变为顺序IO

### 索引是最佳方案吗
* 只有索引带来的好处大于它的开销时，索引才是有效的。
* 对于特别小的表，大部分情况全表扫描更高效。
* 对于中大型表，索引特别有效。
* 对于特大型表，考虑使用分区技术。
* 如果表的数量特别多，可以简历一个元数据信息表，用来查询需要用到的某些特性

## 5.3 高性能索引策略
### 5.3.1 独立的列
* 索引列不能是表达式的一部分
	* SELECT A FROM table WHERE A + 1 = 5;

### 5.3.2 前缀索引和索引选择性
* 选择足够长的前缀以保证较高得到选择性，同时又不能太长。前缀的基数应该接近于完整列的基数
* 计算完整列的选择性
  * SELECT COUNT(DISTINCT city)/COUNT(*) FROM sakila.city_demo;
* 查询不用前缀长度进行计算
  * SELECT COUNT(DISTINCT LEFT(city, 3))/COUNT(*) AS sel3 FROM sakila.city_demo;

### 5.3.3 多列索引
* 给每个列单独建索引是错误的，在查询中同时使用的情况下没有哪个单列索引是非常有效的。
* 当出现多个索引做相交(AND)操作时，通常意味着需要一个包含所有相关列的多列索引，而不是多个独立的单列索引。
* 当出现多个索引做联合(OR)操作时，通常需要耗费大量的CPU资源在算法的缓存、排序和合并操作上。

### 5.3.4 选择合适的索引列顺序
* 正确的顺序依赖于使用该索引的查询，并且同时需要考虑如何更好地满足排序分组的需要。
* 将选择性最高的列放到索引最前列，当不考虑排序和分组时，是很好的选择，只作用于优化WHERE条件的查找。

### 5.3.5 聚簇索引
* 并不是一种单独的索引类型，而是一种数据存储方式。
* 优点
  * 可以把相关属性保存在一起。例如实现电子邮箱时，可以根据用户ID来聚集数据，这样只需要从磁盘读取少数的数据也就能获取某个用户的全部邮件。
  * 数据访问更快。将索引和数据保存在同一个B-Tree中，因此从聚簇索引中获取的数据通常比在非聚簇索引中查找要快。
  * 使用覆盖索引扫描的查询可以直接使用页节点中主键值。

### 5.3.6 覆盖索引
* 包含所有需要查询字段的索引
	