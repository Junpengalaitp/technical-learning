# 并发编程基础
## 1.1 什么是线程
* 线程不是独立存在的，是进程中的一个实体
* 进程是代码在数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位
* 线程是进程的一个执行路径，一个进程中至少有一个线程，进程中的多个线程共享进程的资源
* 操作系统分配资源是分配给进程的，但CPU资源比较特殊，它是被分配到线程的，因为真正占用CPU运行的是线程
* 多个线程共享进程的堆和方法区资源，每个线程有自己的程序计数器和栈区域
  * CPU使用时间片轮转方式让线程轮询占用，所以当前线程CPU时间片用完后，要让出CPU，等下次轮到自己再执行，程序计数器就是记录该线程让出CPU时的执行地址的。
## 1.2 线程的创建与运行
* 继承Thread类
  * 好处: 获取当前线程直接使用this就可以，不需要使用Thread.currentThread()
  * 坏处: 不能多继承，任务与代码没有分离，多个线程执行一样的任务时需要多份任务代码
* 实现Runnable
  * 缺点: 没有返回值
* 实现Callable
  * 好处: 有返回值
  * 坏处: 转化成CallableFuture时会丢失原本实现的接口(例如Comparable)
* 在CompletableFuture中使用Supplier

## 1.3 线程通知与等待
### 1. wait()函数
* 当一个函数调用一个共享变量的wait()方法时，该调用线程会被阻塞挂起，直到发生下面事件之一才返回
  * 其他线程调用了该共享对象的notify()或者notifyAll()方法
  * 其他线程调用了该线程的interrupt()方法
* 调用wait()之前必须先获得监视器锁
  * 执行synchronized同步代码块时，使用该共享变量作为参数
  * 调用该共享变量的方法，并且该方法使用了synchronized修饰
* 虚假唤醒: 一个线程可以从挂起状态变成可运行状态，即使该线程每天被其他线程调用notify(), notifyAll()或者被中断
  * 要不停的测试被唤醒条件是否满足，在一个while循环中调用wait进行防范。

## 1.9 线程死锁
### 1.9.1 什么是线程死锁
* 死锁产生的四个必要条件
  * 互斥条件
    * 线程对已经获取到的资源进行排他性使用。
  * 请求并持有条件
    * 一个线程已经持有了至少一个资源，但又提出了新的资源请求，而请求的新资源已经被其他线程占用，所以当前线程会被阻塞，并且不会释放自己的资源。
  * 不可剥夺条件
    * 线程获取到的资源在自己使用完之前不能被其他线程抢占，只能自己释放
  * 环路等待条件
    * 发生死锁时，必然存在一饿线程->资源的环形链

* 锁顺序死锁
  * 两个线程以不同顺序来获得相同的锁
* 动态的锁顺序死锁
  * 代码里获取锁的顺序一致，但是多个锁对象是从方法参数传人的，如果多个线程传入的参数顺序不一致，就会造成死锁
  * 使用System.identityHashCode方法对锁对象进行排序
* 在协作对象之间发生的死锁
  * 在持有锁的情况下调用某个外部方法，就需要警惕死锁
* 开放调用
  * 调用方法时不需要持有锁
  * 收缩锁的作用域

### 1.9.2 如何避免线程死锁
* 破坏掉至少一个构造死锁的必要条件即可 
  * 只有请求并持有和环路等待条件可以被破坏
* 遵循资源请求有序性原则
  * 不同线程对相同资源的请求顺序相同

* 两阶段策略
  * 找出在什么地方将获取多个锁，对所有这些实例进行全局分析，确保它们在整个程序中获取锁的顺序一致
  * 尽可能地使用开放调用

* 支持定时的锁
  * tryLock

* 通过线程转储信息来分析死锁

### 其他活跃性风险
* 饥饿
  * 线程无法访问它所需要的资源而不能继续执行
* 活锁
  * 线程将不断重复执行相同的操作，并且总会失败