# 并发编程基础
## 1.1 什么是线程
* 线程不是独立存在的，是进程中的一个实体
* 进程是代码在数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位
* 线程是进程的一个执行路径，一个进程中至少有一个线程，进程中的多个线程共享进程的资源
* 操作系统分配资源是分配给进程的，但CPU资源比较特殊，它是被分配到线程的，因为真正占用CPU运行的是线程
* 多个线程共享进程的堆和方法区资源，每个线程有自己的程序计数器和栈区域
  * CPU使用时间片轮转方式让线程轮询占用，所以当前线程CPU时间片用完后，要让出CPU，等下次轮到自己再执行，程序计数器就是记录该线程让出CPU时的执行地址的。
## 1.2 线程的创建与运行
* 继承Thread类
  * 好处: 获取当前线程直接使用this就可以，不需要使用Thread.currentThread()
  * 坏处: 不能多继承，任务与代码没有分离，多个线程执行一样的任务时需要多份任务代码
* 实现Runnable
  * 缺点: 没有返回值
* 实现Callable
  * 好处: 有返回值
  * 坏处: 转化成CallableFuture时会丢失原本实现的接口(例如Comparable)
* 在CompletableFuture中使用Supplier

## 1.3 线程通知与等待
### 1. wait()函数
* 当一个函数调用一个共享变量的wait()方法时，该调用线程会被阻塞挂起，直到发生下面事件之一才返回
  * 其他线程调用了该共享对象的notify()或者notifyAll()方法
  * 其他线程调用了该线程的interrupt()方法
* 调用wait()之前必须先获得监视器锁
  * 执行synchronized同步代码块时，使用该共享变量作为参数
  * 调用该共享变量的方法，并且该方法使用了synchronized修饰
* 虚假唤醒: 一个线程可以从挂起状态变成可运行状态，即使该线程每天被其他线程调用notify(), notifyAll()或者被中断
  * 要不停的测试被唤醒条件是否满足，在一个while循环中调用wait进行防范。