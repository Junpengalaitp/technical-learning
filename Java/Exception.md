# On Java 8 第十五章 异常
* 程序出现问题，你需要停下来，看看是不是有别人或在别的地方能够处理这个问题。只是在当前环境下还没有足够的信息来解决这个问题。所以就把这个问题提交到一个更高级别的环境中，在那里做出正确决定。
* 异常往往能降低代码复杂度。如果不使用异常，那么就必须检查特定的错误，并在程序的许多地方去处理它，如果使用异常，那就不需要在方法调用处进行检查，因为异常机制保证能捕获这个错误。
* 理想情况下只需在一个地方处理错误。这种方式不仅节省代码，并且把正常逻辑和处理错误的逻辑的代码相分离。
* 使用异常机制使代码的阅读、编写和调试工作更加井井有条。

## 基本异常
* 异常情形是指阻止当前方法或作用域继续执行的问题，并且无法在当前作用域获得足够多的信息来解决。所以只能从当前环境跳出，并且把问题提交给上一级环境。
* 抛出异常后的处理流程
  * 使用new在堆上创建异常对象
  * 终止当前执行路径，并从当前环境弹出对异常对象的引用
  * 异常处理机制接管程序，并开始寻找一个恰当的地方来恢复执行程序，这个恰当的地方就是异常处理程序，它的任务是将程序从错误状态中恢复，以使程序要么换一种方式运行，要么继续运行下去。
* 异常机制使你在当前环境下不必为这个问题操心了，它将在别的地方得到处理。
* 异常机制允许你将每件事都当作一个事务来考虑，而异常守护着这些事务，如果任何事出现了错误，我们只需丢弃整个计算。

## 异常参数
* 使用了new创建了异常对象之后，此对象的引用将传递给throw。从效果上来看，它像是从方法返回的。
* 能够抛出任意类型的Throwable对象，它是异常类型的根类。通常，对于不同类型的错误，要抛出相应的异常。错误信息可以保存在异常对象内部或者使用异常类的名称来暗示。上一层环境通过这些信息来决定如何处理异常

## 异常捕获
* 监控区域(guarded region)
  * 一段可能产生异常的代码，并且后面跟着处理这些异常的代码。
  * try语句块
    * 如果在方法内部抛出了异常(或者在方法内部调用的其他方法抛出了异常)，这个方法将在抛出异常的过程中结束，如果不希望方法就此结束，可以在方法内设置一个特殊的块来捕获异常。

  * 异常处理程序
    * try catch
  
  * 终止与恢复
    * 终止模型
      * 假设错误非常严重，以至于程序无法返回到异常发生的地方继续执行。
    * 恢复模型
      * 异常处理程序的工作是修正错误，然后重新尝试调用出问题的方法，并认为第二次能成功。
      * 在异常被处理之后能继续执行程序。如果想要用Java实现类似恢复的行为，那么在遇见错误时就不能抛出异常，而是调用方法来修正该错误。或者把try块放在while循环里，直到得到满意的结构

## 自定义异常
* 继承Exception
  * 可以加入额外的构造器和属性，并重写getMessage()方法

## 捕获所有异常
* 使用Exception基类

## 栈轨迹
* printStackTrace()方法所提供的信息可以通过getStackTrace()方法来直接访问。

## 重新抛出异常
* 在catch块里throw，会将异常抛给上一级的异常处理程序

## 精准的重新抛出异常
* 可以重新抛出的异常类型可以是原异常的基类

## 异常链
* 捕获一个异常后抛出另一个异常，并且希望把原始异常的信息保存下来，被称为异常链。
* 所有Throwable子类在构造器中都可以接受一个cause对象作为参数
* Throwable子类中，只有三种异常提供了带cause的参数构造器
  * Error: JVM报告系统错误
  * Exception
  * RuntimeException
* 使用initCause()方法将其他类型的异常链接起来。

## Java 标准异常
* Throwable这个Java类被用来表示任何可以作为异常被抛出的类。
  * Error: 编译时的系统错误
  * Exception: 可以被抛出的基本类型
* RuntimeException
  * 无法预料的错误
  * 作为程序员应该在代码中进行检查的错误

## 使用 finally 进行清理
* 有一些代码片段，可能会希望无论 try 块中的异常是否抛出，它们都能得到执行。这通常适用于内存回收之外的情况（因为回收由垃圾回收器完成），为了达到这个效果，
可以在异常处理程序后面加上 finally 子句

## 异常限制
* 当覆盖方法的时候，只能抛出在基类方法的异常说明里列出的那些异常。这个限制很有用，因为这意味着与基类一起工作的代码，也能和导出类一起正常工作（这是面向对象的基本概念），异常也不例外。

## 构造器
* 构造器会把对象设置成安全的初始状态，但还会有别的动作，比如打开一个文件，这样的动作只有在对象使用完毕并且用户调用了特殊的清理方法之后才能得以清理。如果在构造器内
抛出了异常，这些清理行为也许就不能正常工作了。这意味着在编写构造器时要格外细心。

## Try-With-Resources 用法
### 异常指南
* 应该在下列情况下使用异常：
  1. 尽可能使用 try-with-resource。
  2. 在恰当的级别处理问题。（在知道该如何处理的情况下才捕获异常。）
  3. 解决问题并且重新调用产生异常的方法。
  4. 进行少许修补，然后绕过异常发生的地方继续执行。
  5. 用别的数据进行计算，以代替方法预计会返回的值。
  6. 把当前运行环境下能做的事情尽量做完，然后把相同的异常重抛到更高层。
  7. 把当前运行环境下能做的事情尽量做完，然后把不同的异常抛到更高层。
  8. 终止程序。
  9. 进行简化。（如果你的异常模式使问题变得太复杂，那用起来会非常痛苦也很烦人。）
  10. 让类库和程序更安全。（这既是在为调试做短期投资，也是在为程序的健壮性做长期投资。）