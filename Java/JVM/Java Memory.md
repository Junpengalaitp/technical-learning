# Java内存区域与内存溢出异常
## 概述
* JVM下的自动内存管理机制不容易出现问题，但是一旦出现问题，不了解JVM使用内存的方式，排查问题就很困难。

## 运行时数据区域
### 程序计数器
* 线程私有，一块较小的内存空间，是当前执行线程的字节码行号指示器。用于线程切换后能够正确继续从挂起的地方执行。
* 执行Java方法时记录字节码指令地址。
* 执行本地方法(native)时，这个计数器值为空。
* 唯一一个没有规定任何OOM的区域。

### JVM栈
* 线程私有，描述Java方法执行的线程内存模型，每个方法被执行的时候，它都会创建一个栈帧来存储局部变量表、操作数栈、动态连接、方法出口等信息。
* 每个方法被调用直至执行完毕，就是一个栈帧push和pop的过程。
* 两类异常
  * StackOverflowError: 线程请求的栈深度大于虚拟机做允许的深度
  * OutOfMemoryError: 栈扩展时无法申请到足够的内存

### Java堆
* 所有线程共享，JVM管理内存中的最大一块，专门用于存放对象实例。
* 垃圾收集器管理的区域，基于分代收集理论设计。(新生代、老年代、永久代等)
* 可以划分出多个线程私有的分配缓冲区(Thread Local Allocation Buffer, TLAB)。以提升对象分配时的效率。
* 可以存储在物理上不连续的空间中，但在逻辑上是连续的。
* 堆的大小是可拓展的，无法拓展时抛出OOM。

### 方法区
* 所有线程共享，存储已被JVM加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。
* JVM规范中描述为堆的一个逻辑部分，但是有个别名Non-heap用于区分。
* JVM规范对方法区很灵活，不需要连续空间，大小可固定可扩展，可选不进行GC。
* 无法满足新的内存需求时，抛出OOM。

### 运行常量池
* 方法区的一部分，存放编译期生成的各种字面量与符号引用。
* JVM规范没有细节要求，各种JVM可以自己实现。
* 因为是方法区的一部分，以同样的方式抛出OOM。

### 直接内存
* 不是JVM运行数据区的组成部分，也不是JVM规范中定义的内存区域。
* JDK1.4后使用NIO的channel与buffer的IO方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里的DirectByteBuffer对象作为这块内存的引用进行操作。避免在Java堆和Native堆反复复制数据。
* 不会收到Java堆大小的限制，但受到物理内存限制，动态扩展时空间不足抛出OOM。

## HotSpot虚拟机对象探秘
### 对象的创建
* 当JVM收到new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。
* 类加载检查通过后，JVM将为新对象分配内存，其所需大小在类加载完成后就可确定。把一块确定大小的内存块从Java堆中分配出来。
  * 内存规整：使用指针碰撞，将指针移动移动对应内存的大小的距离。
  * 不规则: 使用空闲列表。
  * 线程安全性，多个线程同时分配内存引起的问题。
    * JVM默认使用CAS保证原子性
    * 也可以使用本地线程分配缓冲(TLAB)
* JVM对新对象进行必要的设置，例如将类的元数据信息、哈希码、分代信息放入对象头中。
* 此时JVM视角下的对象已经创建完成了，但从Java程序的视角来看，对象创建才刚刚开始，构造函数，即Class文件中的\<init>方法还没执行。所有的字段都为默认的零值。

### 类加载时机
* 七个阶段
  * 加载Loading
  * 验证Verification
  * 准备Preparation
  * 解析Resolution
  * 初始化Initialization
  * 使用Using
  * 卸载Unloading
* 验证->准备->解析过程统称为连接过程
* 加载、验证、准备、初始化的顺序是确定的，但解析不一定，可以在初始化之后再开始，这是为了支持Java语言运行时绑定的特性(多态，后期绑定)。

### 执行第一个加载过程
* Class文件中描述的各类信息最终都需要加载到JVM后才能被运行和使用。
* 在Java里，类型的加载、连接和初始化过程都是在运行时完成，提高了动态扩展的语言特性。
* Class文件中包含了Java虚拟机指令集、符号表以及若干其他辅助信息。

### 六种必须立即对类进行初始化的情况
* 遇到new, getstatic, putstatic, invokestatic这四条字节码指令时。
  * 使用new关键字实例化对象时
  * 读取或设置一个类型的静态字段时，被final修饰的除外，因为已经在编译期间把结果放入了常量池。
  * 调用一个静态方法时
* 使用反射调用时，如果类型没有进行过初始化，则需要先触发触发其初始化。
* 子类初始化时，如果父类还没有初始化，需要先初始化父类。
* 当虚拟机启动时，用户需要一个要执行的主类。
* 当使用JDK加入新的动态语言支持时
* 当接口中定义了默认方法时

## 类加载过程
### 加载
* JVM在加载阶段需要完成的三件事情
  * 通过一个类的全限定名来获取此类的二进制字节流
  * 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
  * 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口
* 获取二进制字节流的来源
  * 从某个Class文件中获取
  * 从压缩包中获取
  * 从网络中获取，Web Applet
  * 运行时生成，动态代理技术
  * 从其他文件生成，JSP技术
  * 从数据库读取, 中间件服务器SAP NetWeaver可以把程序安装到数据库中来完成程序代码在集群间的分发
  * 从加密文件中获取
* 类加载过程的其他阶段
  * 非数组类型的加载阶段最灵活，既可以使用JVM内置的引导类加载器，也可以由用户定义得到类加载器。
  * 数组类本身不通过类加载器创建，由JVM直接来内存中动态构造出来的。
* 加载阶段结束后，JVM外部得到二进制字节流就按JVM所设定的格式存储在方法区中了，存储格式由JVM自行实现定义。
* 类型数据安置在方法区后，会在JVM堆内存上实例化一个java.lang.Class对象，这个对象将作为程序访问方法区中类型数据得到外部接口。
* 加载阶段与连接阶段的部分动作是交叉进行的，但连接阶段的步骤仍然保持有序

### 验证
* 连接阶段的第一步，确保Class文件的字节流中包含的信息符号JVM的全部约束要求以保证安全。
* 四个阶段
  * 文件格式验证
    * 是否以魔法数0xCAFEBABE开头
    * 主次版本号是否在当前JVM的接受范围之内
    * 常量池的常量中是否由不被支持的常量类型
    * ...
  * 元数据验证
    * 进行语义分析，确保符合Java语言规范的要求
    * 是否有父类，除了Object对象之外，所有类都应该有父类
    * 对象是否继承了不被允许继承的类，被final修饰的类
    * 如果不是抽象类，是否实现了其父类或接口中要求实现的所有方法
    * 类中的字段、方法是否与父类矛盾
    * ...
  * 字节码验证
    * 最复杂的阶段，目的是通过数据流分析和控制流分析，确定语义的合法性和逻辑。
    * 对类的方法体进行校验分析，保证方法在运行时不会危害JVM。
      * 保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作。
      * 保证任何跳转指令都不会跳转到方法体之外的字节码指令上。
      * 保证方法体中得到类型转化总是有效的。
      * ...
  * 符号引用验证
    * JVM将符号引用转化为直接引用时验证，检查该类是否缺少或禁止访问它的依赖
      * 符号引用中通过字符串描述的全限定名是否能找到对应的类
      * 在指定类中是否存在符合方法的字段描述以及简单名称所描述的方法和字段
      * 符号所引用的类、字段、方法的可访问性(private, protected, public...)
      * 失败会抛出IncompatibleClassChangeError.
        * IllegalAccessError
        * NoSuchFieldError
        * NoSuchMethodError
### 准备
* 正式为类中定义的变量(即静态变量)分配内存并设置类变量的初始化阶段
* 仅包括类变量，不包括实例变量
* 除了final变量以外的值都是默认值，即使有赋值语句也要到putstatic命令执行时

### 解析
* 将常量池内的符号引用替换为直接引用的过程
  * 符号引用：以一组符号来描述所引用的目标，可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。
  * 直接引用：可以直接指向目标的指针

### 初始化
* 前面的步骤除了加载阶段用户可以自定义加载器，其余都由JVM控制，初始化步骤，JVM才开始真正执行程序代码，将主导权交给应用程序。
* 准备阶段变量赋了默认值，初始化阶段根据程序员的编码去赋值，执行\<clinit>过程。
* \<clinit>()方法是由编译器自动收集类中的所有类变量赋值动作和静态语句块(static块)中的语句合并产生的。编译器收集的顺序由语句在源文件中出现的顺序决定。
* 静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。
* \<clinit>()方法不同于\<init>()方法，它不需要显示调用父类构造器，JVM会保证父类的\<clinit>()方法已经执行完毕，因此java.lang.Object是第一个被执行的\<clinit>()方法的对象。
* \<clinit>()方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成\<clinit>()方法。
* 接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成\<clinit>()方法。但接口与类不同的是，执行接口的\<clinit>()方法不需要先执行父接口的\<clinit>()方法， 因为只有当父接口中定义的变量被使用时，父接口才会被初始化。此外，接口的实现类在初始化时也 一样不会执行接口的\<clinit>()方法。
* Java虚拟机必须保证一个类的\<clinit>()方法在多线程环境中被正确地加锁同步，如果多个线程同时去初始化一个类，那么只会有其中一个线程去执行这个类的\<clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行完毕\<clinit>()方法。如果在一个类的\<clinit>()方法中有耗时很长的操作，那就 可能造成多个进程阻塞[2]，在实际应用中这种阻塞往往是很隐蔽的。
## 类加载器
* 实现“通过一个类的全限定名来获取描述该类的二进制字节流”放到JVM外面

### 类与类加载器
* 对于任意一个类，都必须由加载它的类加载器和类本身一起共同确立其在JVM中的唯一性，每个类加载器都有一个独立的类名称空间。
  
### 双亲委派模型(Parent Delegation Model)
* 站在Java虚拟机的角度来看，只存在两种不同的类加载器：
  * 启动类加载器（Bootstrap ClassLoader），这个类加载器使用C++语言实现[1]，是虚拟机自身的一部分；
  * 其他所有的类加载器，这些类加载器都由Java语言实现，独立存在于虚拟机外部，并且全都继承自抽象类 java.lang.ClassLoader。
  
* 站在Java开发人员的角度来看，类加载器就应当划分得更细致一些。自JDK1.2以来，Java一直保持着三层类加载器、双亲委派的类加载架构
  * Bootstrap Class Loader，启动类加载器
    * 负载加载存放在JAVA_HOME\lib目录或者-Xbootclasspath参数所指定的路径下存放的、可被JVM识别的类库。
    * Bootstrap Class Loader无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器处理，直接使用null代替即可。
  * Extension Class Loader, 扩展类加载器，以Java代码实现，负责加载JAVA_HOME\lib\ext目录中，或者被java.ext.dirs系统变量所指定的路径中所有的类库。
  * Application Class Loader, 应用程序类加载器，负责加载用户类路径上所有的类库，也可以直接在代码中使用
* JDK9之前的Java应用都是由这三种类加载器互相配合来完成加载的，如果用户认为有必要，也可以加入自定义类加载器来进行扩展。
* 各种类加载器的层次关系被称为类加载器的双亲委派模型(Parent Delegation Model)。除了顶层的启动类加载器外，其它的加载器都应该有自己的父加载器，但非继承实现，而是组合实现。
* 当加载器收到请求时，首先会层层递归请求自己的上一级加载器处理，只有父加载器无法处理时，会把信息返回，子加载器再自己加载
  * 因为由不同加载器类型加载的相同类会被视为不同类，所以要保证能被父加载器加载的类都交给父加载器加载，例如java.lang.Object类，如果给子加载器自己加载，那么就会出大问题

### 破坏双亲委派模型


## JVM内存异常
### StackOverflowError
* 当线程请求的栈深度大于JVM允许的最大深度时抛出。
* HotSpot虚拟机默认不支持栈的动态扩展，所以除非在创建线程时就OOM了，否则在线程运行时只会有StackOverflowError。
* 栈帧太大或者栈深度不足都会抛出StackOverflowError

### OutOfMemoryError
* Java堆溢出
  * 不断创建新对象而不进行回收，最终就会OOM
* 方法区和运行时常量池
  * JDK8中使用元空间代替了永久代，OOM中不会出现PermGen space
* 直接内存溢出
  * Heap Dump文件中不会看见有明显溢出情况。
  