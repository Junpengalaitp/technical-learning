# 垃圾收集器与内存分配策略
## 概述
* Java线程私有的程序计数器、虚拟机栈、本地方法栈随着线程的生命周期进行创建和回收。并且每个栈帧分配多少内存是在类结构确定时就已知的。所以这几个区域的内存回收随着方法或线程结束时就会回收。
* Java的堆和方法区有很大的不确定性，一个接口的每个具体实现需要的内存都不一样，一个方法所执行的不同条件分支需要的内存也可能不一样，只有在运行期间才能知道。所以这部分内存的分配和回收是动态的。

## 对象死亡判断
### 引用计数法
* 实现简单，效率也高，但是无法解决环形引用

### 可达性分析算法
* GC Roots：根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索的过程所走过的路径称为引用链。
  * 虚拟机栈中引用的对象
  * 方法区中类静态属性引用的对象
  * 方法区中常量引用的对象
  * 在本地方法栈中JNI(Native方法)引用的对象
  * JVM内部的引用，基本数据类型对应的class对象，一些常驻的异常(NPE, OOM)，还有系统类加载器
  * 被同步锁(synchronized关键字)持有的对象
  * 反映JVM虚拟机内部情况的JMXBean、JVMTI中注册的回调，本地缓存代码等。

### 引用
* 强引用
* 软引用
* 弱引用
* 虚引用

### 对象的生死判断
* 至少需要经历两次标记过程
  * 如果对象在可达性分析后没有与GC Roots相连接的引用链，那它将会被第一次标记，随后进行一次筛选，条件是此对象是否有必要执行finalize方法。假如对象没有重写finalize方法，或者已被执行过，都被JVM视为没有必要执行
  * 如果有必要执行finalize方法，该对象会被放置在一个名为F-Queue的队列中，稍后由JVM的Finalizer线程去执行它们的finalize方法。

## 垃圾收集算法
### 分代收集理论
* 弱分代假说：绝大多数对象的生命周期很短
* 强分代假说：熬过越多次垃圾收集的对象越难以消亡

### 标记-清除算法
* 标记死亡/存活的对象后，统一回收所有未被标记的对象。

### 标记-复制算法
* 每次使用内存的一半，每次将存活的对象复制到另一半，然后全部清除。

### 标记-整理算法
* 让所有存活的对象移动到内存空间的一边，然后清理掉边界以外的内存。
