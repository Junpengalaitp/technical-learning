# 工厂方法(Factory Method)
* 在父亲类中提供一个创建对象的方法，允许子类决定实例化对象的类型。
* 优点
  * 避免创建者和具体函数之间的紧耦合
  * 单一职责原则
  * 开闭原则，无须更改现有代码引入新的产品类型
* 缺点
  * 产品可能会产生大量子类
  * 最好将该模式引入创建者类的现有层次结构中
* 适用场景
  * 无法预知对象确切类别及其依赖关系时
    * 将创建产品的代码与实际适用产品的代码分离，从而能在不影响其他代码的情况下扩展产品创建代码
  * 希望用户能扩展你的软件库或框架内部组件时
  * 希望复用现有对象来节省系统资源时
    * 既能创建对象，又可以重用现有对象的普通方法
    * 实际例子: 领域事件工厂中，某些事件不依赖外部参数，所以该事件是可以复用的，结合单例模式实现
  * 将Switch语句埋到工厂方法底下，用于创建多态对象
* 与其他模式的关系
  * 设计初期都会使用简单的工厂模式，随后演化成抽象工厂模式、原型模式或生成器模式
  * 结合工厂和迭代器模式让子类集合返回不同类型的迭代器
  * 工厂方法是模版方法的一种特殊形式，可以所为一个大型模版方法中的一个步骤

# 抽象工厂(Abstract Factory)
* 能够创建一系列相关的对象，而无需指定其具体类
* 为每个系列的产品声明明确接口(例如椅子、沙发或咖啡桌)，确保所有产品变体都继承这些接口。
* 声明抽象工厂，包含系列中所有产品构造方法的接口(创建椅子、创建沙发、创建咖啡桌)。
* 这些方法必须返回抽象产品类型，即我们之前抽取的那些接口。
* 对于系列产品的每个变体，都基于抽象工厂创建不同的工厂类，每个工厂类只返回特定类别的产品，例如现代家具工厂只创建现代椅子、现代沙发和现代咖啡桌对象
* 客户端代码可以通过相应的抽象接口调用工厂和产品类，无需修改事件客户端代码，就能更改传递给客户端的工厂类，也能更改客户端代码接收的产品变体。
### 实现方式
1. 以不同的产品类型与产品变体为维度绘制矩阵
2. 为所有产品声明抽象产品接口
3. 声明工厂接口，在接口中为所有抽象产品提供一组构建方法
4. 为每种产品变体实现一个具体工厂类
5. 在应用程序中开发初始化代码，根据配置或环境对特定工厂类进行初始化。然后将该工厂对象传递给所有需要创建产品的类
6. 找出代码中所有对产品构造函数的之间调用，将其替换为工厂对象中相应构建方法的调用
### 优缺点
* 优点
  * 确保同一工厂生成的产品相互匹配
  * 避免客户端和具体产品代码耦合
  * 单一职责原则
  * 开闭原则
* 缺点
  * 需要引入众多接口和类，代码可能会比之前更加复杂
# 建造器(Builder)

# 原型(Prototype)

# 单例(Singleton)