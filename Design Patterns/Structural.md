# 适配器(Adapter)

# 桥梁(Bridge)

# 组合(Composite)
## 意图
* 可以使用它将对象组合成树状结构，并且能像使用独立对象一样使用它们
* 如何应用的核心模型能用树状结构表示，在应用中使用组合模式才有价值
## 使用场景
* 需要实现树状对象结构，可以使用组合模式
* 希望客户端代码以相同方式处理简单和复杂元素，可以使用该模式
## 实现方式
1. 确保应用的核心模型能够以树状结构表示。尝试将其分解为简单元素和容器，容器必须能够同时包含简单元素和其他容器。
2. 声明组件接口及其一系列方法，这些方法对简单和复杂元素都有意义。
3. 创建一个叶节点表示简单元素。可以有多个不同叶节点类。
4. 创建一个容器表示复杂元素。在该类中，创建一个数组成员变量来存储对于其子元素得到引用。该数组必须能够同时保存叶节点和容器。实现组件接口方法时，容器应该将大部分工作交给其子元素来完成。
5. 在容器中定义和添加删除子元素的方法
## 优缺点
* 优点
  * 利用多态和递归更方便地使用复杂树结构
  * 开闭原则，无需更改现有代码，就可以添加新元素，使其成为对象树的一部分
* 缺点
  * 对于功能差异较大的类，提供公共接口或许比较困难。有时需要过度一般化组件接口，使其变得令人难以理解

## 与其他模式的关系
* 和桥接模式、状态模式、策略模式和适配器模式的接口非常相似。它们都基于组合模式，即将工作委派给其他对象。
* 可以在创建复杂树是使用生成器模式，可使其构造步骤以递归的方式运行。
* 责任链模式通常和组合模式结合使用。这种情况下，叶组件接收到请求后，可以将请求递归传递到对象树底部
* 你可以使用迭代器模式来遍历组合树。
* 你可以使用访问者模式对整个组合树执行操作。
* 你可以使用享元模式实现组合树的共享叶节点以节省内存。
* 组合和装饰模式的结构图很相似， 因为两者都依赖递归组合来组织无限数量的对象。
* 装饰类似于组合， 但其只有一个子组件。 此外还有一个明显不同： 装饰为被封装对象添加了额外的职责， 组合仅对其子节点的结果进行了 “求和”。
  但是， 模式也可以相互合作： 你可以使用装饰来扩展组合树中特定对象的行为。
* 大量使用组合和装饰的设计通常可从对于原型模式的使用中获益。 你可以通过该模式来复制复杂结构， 而非从零开始重新构造。

# 装饰(Decorator)

# 门面(Facade)

# 享元(Flyweight)

# 代理(Proxy)