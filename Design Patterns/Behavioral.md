# 责任链(Chain of Responsibility)

# 命令(Command)

# 迭代器(Iterator)

# 中介(Mediator)

# 备忘录(Memento)

# 观察者(Observer)

# 状态(State)

# 策略(Strategy)

# 模版方法(Template Method) 
## 意图
* 它在超类中定义了一个算法的框架， 允许子类在不修改结构的情况下重写算法的特定步骤。
* 模板方法模式建议将算法分解为一系列步骤， 然后将这些步骤改写为方法， 最后在 “模板方法” 中依次调用这些方法。 步骤可以是 抽象的， 也可以有一些默认的实现。 为了能够使用算法， 客户端需要自行提供子类并实现所有的抽象步骤。 如有必要还需重写一些步骤 （但这一步中不包括模板方法自身）。
## 应用场景
* 当你只希望客户端扩展某个特定算法步骤， 而不是整个算法或其结构时， 可使用模板方法模式。
* 模板方法将整个算法转换为一系列独立的步骤， 以便子类能对其进行扩展， 同时还可让超类中所定义的结构保持完整。
* 当多个类的算法除一些细微不同之外几乎完全一样时， 你可使用该模式。 但其后果就是， 只要算法发生变化， 你就可能需要修改所有的类。
* 在将算法转换为模板方法时， 你可将相似的实现步骤提取到超类中以去除重复代码。 子类间各不同的代码可继续保留在子类中。
## 实现方式
* 分析目标算法， 确定能否将其分解为多个步骤。 从所有子类的角度出发， 考虑哪些步骤能够通用， 哪些步骤各不相同。
* 创建抽象基类并声明一个模板方法和代表算法步骤的一系列抽象方法。 在模板方法中根据算法结构依次调用相应步骤。 可用 final最终修饰模板方法以防止子类对其进行重写。
* 虽然可将所有步骤全都设为抽象类型， 但默认实现可能会给部分步骤带来好处， 因为子类无需实现那些方法。
* 可考虑在算法的关键步骤之间添加钩子。
* 为每个算法变体新建一个具体子类， 它必须实现所有的抽象步骤， 也可以重写部分可选步骤。
## 优缺点
* 优点
  * 你可仅允许客户端重写一个大型算法中的特定部分， 使得算法其他部分修改对其所造成的影响减小。
  * 你可将重复代码提取到一个超类中。
* 缺点
  * 部分客户端可能会受到算法框架的限制。
  * 通过子类抑制默认步骤实现可能会导致违反 里氏替换原则。
  * 模板方法中的步骤越多， 其维护工作就可能会越困难。
## 与其他模式的关系
* 工厂方法模式是模板方法模式的一种特殊形式。 同时， 工厂方法可以作为一个大型模板方法中的一个步骤。
* 模板方法基于继承机制： 它允许你通过扩展子类中的部分内容来改变部分算法。 策略模式基于组合机制： 你可以通过对相应行为提供不同的策略来改变对象的部分行为。 模板方法在类层次上运作， 因此它是静态的。 策略在对象层次上运作， 因此允许在运行时切换行为。

## 例子
* 报价订阅的基类模板
  * 第一步：先验证订阅类型(抽象方法，每个子类验证是不是它应该接受的货币对和期限)
  * 第二步：进行实际的拆分订阅(抽象方法，结合组合模式实现)
  * 第三步: 如果订阅成功，发送订阅后的价格(通用方法，不需要子类重写)

# 访问者(Visitor)